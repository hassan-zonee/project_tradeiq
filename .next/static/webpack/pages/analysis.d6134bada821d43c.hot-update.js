"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/analysis",{

/***/ "(pages-dir-browser)/./components/CandleChart.tsx":
/*!************************************!*\
  !*** ./components/CandleChart.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandleChart: () => (/* binding */ CandleChart)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(pages-dir-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n\nvar _s = $RefreshSig$();\n\n\n// Helper function to calculate Exponential Moving Average (EMA)\nconst calculateEMA = (data, period)=>{\n    const emaData = [];\n    if (data.length < period) return emaData;\n    const k = 2 / (period + 1);\n    // First EMA is an SMA\n    let sumForSma = 0;\n    for(let i = 0; i < period; i++){\n        sumForSma += data[i].close;\n    }\n    let prevEma = sumForSma / period;\n    emaData.push({\n        time: data[period - 1].time,\n        value: prevEma\n    });\n    for(let i = period; i < data.length; i++){\n        const currentEma = data[i].close * k + prevEma * (1 - k);\n        emaData.push({\n            time: data[i].time,\n            value: currentEma\n        });\n        prevEma = currentEma;\n    }\n    return emaData;\n};\n// Helper function to calculate Relative Strength Index (RSI)\nconst calculateRSI = function(data) {\n    let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 14;\n    const rsiData = [];\n    let gains = 0;\n    let losses = 0;\n    // Calculate initial average gains and losses\n    for(let i = 1; i <= period; i++){\n        const change = data[i].close - data[i - 1].close;\n        if (change > 0) {\n            gains += change;\n        } else {\n            losses -= change; // losses are positive\n        }\n    }\n    let avgGain = gains / period;\n    let avgLoss = losses / period;\n    if (avgLoss === 0) {\n        rsiData.push({\n            time: data[period].time,\n            value: 100\n        });\n    } else {\n        const rs = avgGain / avgLoss;\n        rsiData.push({\n            time: data[period].time,\n            value: 100 - 100 / (1 + rs)\n        });\n    }\n    // Calculate subsequent RSI values\n    for(let i = period + 1; i < data.length; i++){\n        const change = data[i].close - data[i - 1].close;\n        let currentGain = 0;\n        let currentLoss = 0;\n        if (change > 0) {\n            currentGain = change;\n        } else {\n            currentLoss = -change;\n        }\n        avgGain = (avgGain * (period - 1) + currentGain) / period;\n        avgLoss = (avgLoss * (period - 1) + currentLoss) / period;\n        if (avgLoss === 0) {\n            rsiData.push({\n                time: data[i].time,\n                value: 100\n            });\n        } else {\n            const rs = avgGain / avgLoss;\n            rsiData.push({\n                time: data[i].time,\n                value: 100 - 100 / (1 + rs)\n            });\n        }\n    }\n    return rsiData;\n};\n// Helper function to calculate Parabolic SAR (PSAR)\nconst calculateParabolicSAR = function(data) {\n    let initialAf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.02, incrementAf = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.02, maxAf = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.20;\n    const psarData = [];\n    if (data.length < 2) return psarData;\n    let isLong = data[1].close > data[0].close; // Initial trend guess\n    let af = initialAf;\n    let extremePoint = isLong ? Math.max(data[0].high, data[1].high) : Math.min(data[0].low, data[1].low);\n    let sar = isLong ? data[0].low : data[0].high;\n    // First point (or first calculable point)\n    // The first SAR point is typically the prior EP (high for short, low for long)\n    // For simplicity, we start calculating SAR from the second bar, using the first bar's data for initial EP/SAR.\n    // Some implementations might skip the first few bars or use different initialization.\n    psarData.push({\n        time: data[0].time,\n        value: sar\n    });\n    for(let i = 1; i < data.length; i++){\n        const prevSar = sar;\n        const prevAf = af;\n        const prevExtremePoint = extremePoint;\n        if (isLong) {\n            sar = prevSar + prevAf * (prevExtremePoint - prevSar);\n            if (data[i].low < sar) {\n                isLong = false;\n                sar = prevExtremePoint; // SAR becomes the highest point of the previous uptrend\n                extremePoint = data[i].low;\n                af = initialAf;\n            } else {\n                if (data[i].high > prevExtremePoint) {\n                    extremePoint = data[i].high;\n                    af = Math.min(maxAf, prevAf + incrementAf);\n                }\n            }\n        } else {\n            sar = prevSar - prevAf * (prevSar - prevExtremePoint);\n            if (data[i].high > sar) {\n                isLong = true;\n                sar = prevExtremePoint; // SAR becomes the lowest point of the previous downtrend\n                extremePoint = data[i].high;\n                af = initialAf;\n            } else {\n                if (data[i].low < prevExtremePoint) {\n                    extremePoint = data[i].low;\n                    af = Math.min(maxAf, prevAf + incrementAf);\n                }\n            }\n        }\n        // Ensure SAR does not cross the previous or current period's high/low too aggressively\n        if (isLong) {\n            sar = Math.min(sar, data[i - 1].low, i > 1 ? data[i - 2].low : data[i - 1].low);\n            if (data[i].low < sar) sar = data[i].low; // Additional check if SAR is broken intraday\n        } else {\n            sar = Math.max(sar, data[i - 1].high, i > 1 ? data[i - 2].high : data[i - 1].high);\n            if (data[i].high > sar) sar = data[i].high; // Additional check\n        }\n        psarData.push({\n            time: data[i].time,\n            value: sar\n        });\n    }\n    return psarData;\n};\nconst calculateMACD = function(data) {\n    let fastPeriod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 12, slowPeriod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 26, signalPeriod = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 9;\n    const macdLine = [];\n    const signalLine = [];\n    const histogram = [];\n    if (data.length < slowPeriod) return {\n        macdLine,\n        signalLine,\n        histogram\n    };\n    const fastEMACalc = calculateEMA(data, fastPeriod);\n    const slowEMACalc = calculateEMA(data, slowPeriod);\n    // Align EMAs and calculate MACD line\n    // EMAs might have different starting points, so we need to align them by time\n    const alignedMacdValues = [];\n    let slowIdx = 0;\n    for(let i = 0; i < fastEMACalc.length; i++){\n        const fastPoint = fastEMACalc[i];\n        while(slowIdx < slowEMACalc.length && slowEMACalc[slowIdx].time < fastPoint.time){\n            slowIdx++;\n        }\n        if (slowIdx < slowEMACalc.length && slowEMACalc[slowIdx].time === fastPoint.time) {\n            const macdValue = fastPoint.value - slowEMACalc[slowIdx].value;\n            macdLine.push({\n                time: fastPoint.time,\n                value: macdValue\n            });\n            alignedMacdValues.push({\n                time: fastPoint.time,\n                value: macdValue\n            });\n        }\n    }\n    if (alignedMacdValues.length < signalPeriod) return {\n        macdLine,\n        signalLine,\n        histogram\n    };\n    // Calculate Signal line (EMA of MACD line)\n    // We need to convert MACD values to CandlestickData-like structure for calculateEMA\n    const macdForSignalEMA = alignedMacdValues.map((p)=>({\n            time: p.time,\n            open: p.value,\n            high: p.value,\n            low: p.value,\n            close: p.value\n        }));\n    const signalLineCalc = calculateEMA(macdForSignalEMA, signalPeriod);\n    signalLine.push(...signalLineCalc);\n    // Align MACD and Signal lines and calculate Histogram\n    let signalIdx = 0;\n    for(let i = 0; i < macdLine.length; i++){\n        const macdPoint = macdLine[i];\n        while(signalIdx < signalLine.length && signalLine[signalIdx].time < macdPoint.time){\n            signalIdx++;\n        }\n        if (signalIdx < signalLine.length && signalLine[signalIdx].time === macdPoint.time) {\n            const histValue = macdPoint.value - signalLine[signalIdx].value;\n            histogram.push({\n                time: macdPoint.time,\n                value: histValue,\n                color: histValue >= 0 ? 'rgba(0, 150, 136, 0.8)' : 'rgba(255, 82, 82, 0.8)'\n            });\n        }\n    }\n    return {\n        macdLine,\n        signalLine,\n        histogram\n    };\n};\n// Helper function to calculate Bollinger Bands\nfunction calculateBollingerBands(data) {\n    let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, k = arguments.length > 2 && arguments[2] !== void 0 // Standard deviations\n     ? arguments[2] : 2;\n    const upperData = [];\n    const middleData = [];\n    const lowerData = [];\n    if (data.length < period) {\n        return {\n            upper: upperData,\n            middle: middleData,\n            lower: lowerData\n        };\n    }\n    for(let i = period - 1; i < data.length; i++){\n        const currentSlice = data.slice(i - period + 1, i + 1);\n        const closes = currentSlice.map((d)=>d.close);\n        const currentTime = data[i].time;\n        const sma = closes.reduce((acc, val)=>acc + val, 0) / period;\n        if (isNaN(sma)) continue; // Skip if SMA is not a number\n        middleData.push({\n            time: currentTime,\n            value: sma\n        });\n        let variance = 0;\n        for (const close of closes){\n            variance += Math.pow(close - sma, 2);\n        }\n        const stdDev = Math.sqrt(variance / period);\n        const upperBandValue = sma + k * stdDev;\n        if (!isNaN(upperBandValue)) {\n            upperData.push({\n                time: currentTime,\n                value: upperBandValue\n            });\n        }\n        const lowerBandValue = sma - k * stdDev;\n        if (!isNaN(lowerBandValue)) {\n            lowerData.push({\n                time: currentTime,\n                value: lowerBandValue\n            });\n        }\n    }\n    return {\n        upper: upperData,\n        middle: middleData,\n        lower: lowerData\n    };\n}\nconst CandleChart = (param)=>{\n    let { data, showIndicators = false, visibleIndicators = [], keyLevels } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const rsiSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const macdLineSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const macdSignalSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const macdHistogramSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const ema21SeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const ema50SeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const ema200SeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const parabolicSARSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const bbUpperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const bbMiddleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const bbLowerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const supportLineRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const resistanceLineRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CandleChart.useEffect\": ()=>{\n            if (!chartContainerRef.current) return;\n            // Initialize chart\n            if (!chartRef.current) {\n                chartRef.current = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n                    width: chartContainerRef.current.clientWidth,\n                    height: chartContainerRef.current.clientHeight,\n                    layout: {\n                        background: {\n                            color: '#ffffff'\n                        },\n                        textColor: '#333'\n                    },\n                    grid: {\n                        vertLines: {\n                            color: '#e1e1e1'\n                        },\n                        horzLines: {\n                            color: '#e1e1e1'\n                        }\n                    },\n                    timeScale: {\n                        rightOffset: 15,\n                        barSpacing: 8,\n                        borderColor: '#cccccc',\n                        timeVisible: true,\n                        secondsVisible: false\n                    }\n                });\n                candlestickSeriesRef.current = chartRef.current.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.CandlestickSeries, {\n                    upColor: '#26a69a',\n                    downColor: '#ef5350',\n                    borderVisible: false,\n                    wickUpColor: '#26a69a',\n                    wickDownColor: '#ef5350'\n                });\n            }\n            // Update candlestick data\n            if (chartRef.current && candlestickSeriesRef.current && data.length > 0) {\n                candlestickSeriesRef.current.setData(data);\n                // Set a default visible range to show the last 70 candles with padding\n                const dataLength = data.length;\n                if (dataLength > 0) {\n                    const PADDING_BARS = 0 // Match this with timeScale.rightOffset if desired\n                    ;\n                    const logicalFrom = Math.max(0, dataLength - 50); // Show latest 70 data points\n                    const logicalTo = dataLength - 1 + PADDING_BARS; // Extend range by PADDING_BARS beyond the last data point\n                    chartRef.current.timeScale().setVisibleLogicalRange({\n                        from: logicalFrom,\n                        to: logicalTo\n                    });\n                }\n            } else if (candlestickSeriesRef.current) {\n                candlestickSeriesRef.current.setData([]); // Clear data if `data` prop is empty\n            }\n            // Resize observer\n            const resizeObserver = new ResizeObserver({\n                \"CandleChart.useEffect\": (entries)=>{\n                    var _chartRef_current;\n                    if (entries.length === 0 || entries[0].target !== chartContainerRef.current) {\n                        return;\n                    }\n                    const { width, height } = entries[0].contentRect;\n                    (_chartRef_current = chartRef.current) === null || _chartRef_current === void 0 ? void 0 : _chartRef_current.applyOptions({\n                        width,\n                        height\n                    });\n                }\n            }[\"CandleChart.useEffect\"]);\n            resizeObserver.observe(chartContainerRef.current);\n            return ({\n                \"CandleChart.useEffect\": ()=>{\n                    resizeObserver.disconnect();\n                // Chart removal is handled in the indicator effect's cleanup if showIndicators changes\n                // Or here if the component unmounts entirely.\n                // If we only remove series, the chart instance can persist.\n                }\n            })[\"CandleChart.useEffect\"];\n        }\n    }[\"CandleChart.useEffect\"], [\n        data\n    ]); // Only re-run if data changes. Chart creation is once.\n    // Effect for handling indicators\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CandleChart.useEffect\": ()=>{\n            if (!chartRef.current || !candlestickSeriesRef.current || !data || data.length < 20) {\n                return;\n            }\n            const chart = chartRef.current;\n            const series = candlestickSeriesRef.current;\n            // Clear and draw key level lines\n            if (supportLineRef.current) {\n                series.removePriceLine(supportLineRef.current);\n                supportLineRef.current = null;\n            }\n            if (resistanceLineRef.current) {\n                series.removePriceLine(resistanceLineRef.current);\n                resistanceLineRef.current = null;\n            }\n            if (keyLevels === null || keyLevels === void 0 ? void 0 : keyLevels.support) {\n                supportLineRef.current = series.createPriceLine({\n                    price: keyLevels.support,\n                    color: '#ef4444',\n                    lineWidth: 3,\n                    lineStyle: lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineStyle.Dashed,\n                    axisLabelVisible: true,\n                    title: ''\n                });\n            }\n            if (keyLevels === null || keyLevels === void 0 ? void 0 : keyLevels.resistance) {\n                resistanceLineRef.current = series.createPriceLine({\n                    price: keyLevels.resistance,\n                    color: '#ef4444',\n                    lineWidth: 3,\n                    lineStyle: lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineStyle.Dashed,\n                    axisLabelVisible: true,\n                    title: ''\n                });\n            }\n            const removeSeries = {\n                \"CandleChart.useEffect.removeSeries\": (seriesRef)=>{\n                    if (seriesRef.current) {\n                        try {\n                            chart.removeSeries(seriesRef.current);\n                        } catch (e) {\n                            console.warn(\"Failed to remove series:\", e);\n                        }\n                        seriesRef.current = null;\n                    }\n                }\n            }[\"CandleChart.useEffect.removeSeries\"];\n            // Clear all indicators before redrawing\n            removeSeries(rsiSeriesRef);\n            removeSeries(macdLineSeriesRef);\n            removeSeries(macdSignalSeriesRef);\n            removeSeries(macdHistogramSeriesRef);\n            removeSeries(ema21SeriesRef);\n            removeSeries(ema50SeriesRef);\n            removeSeries(ema200SeriesRef);\n            removeSeries(parabolicSARSeriesRef);\n            removeSeries(bbUpperRef);\n            removeSeries(bbMiddleRef);\n            removeSeries(bbLowerRef);\n            if (showIndicators) {\n                if (visibleIndicators.includes('rsi')) {\n                    const rsiData = calculateRSI(data, 14);\n                    if (rsiData.length > 0) {\n                        rsiSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            color: 'rgba(128, 0, 128, 0.8)',\n                            lineWidth: 2,\n                            priceScaleId: '',\n                            autoscaleInfoProvider: {\n                                \"CandleChart.useEffect\": ()=>({\n                                        priceRange: {\n                                            minValue: 0,\n                                            maxValue: 100\n                                        }\n                                    })\n                            }[\"CandleChart.useEffect\"],\n                            lastValueVisible: true,\n                            priceLineVisible: true\n                        });\n                        rsiSeriesRef.current.setData(rsiData);\n                        chart.priceScale('').applyOptions({\n                            scaleMargins: {\n                                top: 0.8,\n                                bottom: 0\n                            }\n                        });\n                    }\n                }\n                if (visibleIndicators.includes('macd')) {\n                    const { macdLine, signalLine, histogram } = calculateMACD(data);\n                    const macdPaneId = 'macdPane';\n                    if (macdLine.length > 0) {\n                        macdLineSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            color: 'rgba(0, 120, 255, 0.8)',\n                            lineWidth: 2,\n                            priceScaleId: macdPaneId\n                        });\n                        macdLineSeriesRef.current.setData(macdLine);\n                    }\n                    if (signalLine.length > 0) {\n                        macdSignalSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            color: 'rgba(255, 100, 0, 0.8)',\n                            lineWidth: 2,\n                            priceScaleId: macdPaneId\n                        });\n                        macdSignalSeriesRef.current.setData(signalLine);\n                    }\n                    if (histogram.length > 0) {\n                        macdHistogramSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.HistogramSeries, {\n                            priceScaleId: macdPaneId\n                        });\n                        macdHistogramSeriesRef.current.setData(histogram);\n                    }\n                    if (macdLine.length > 0 || signalLine.length > 0 || histogram.length > 0) {\n                        chart.priceScale(macdPaneId).applyOptions({\n                            scaleMargins: {\n                                top: 0.7,\n                                bottom: 0\n                            }\n                        });\n                    }\n                }\n                if (visibleIndicators.includes('ema21')) {\n                    const emaData = calculateEMA(data, 21);\n                    if (emaData.length > 0) {\n                        ema21SeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            color: 'rgba(255, 215, 0, 0.8)',\n                            lineWidth: 1\n                        });\n                        ema21SeriesRef.current.setData(emaData);\n                    }\n                }\n                if (visibleIndicators.includes('ema50')) {\n                    const emaData = calculateEMA(data, 50);\n                    if (emaData.length > 0) {\n                        ema50SeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            color: 'rgba(30, 144, 255, 0.8)',\n                            lineWidth: 1\n                        });\n                        ema50SeriesRef.current.setData(emaData);\n                    }\n                }\n                if (visibleIndicators.includes('ema200')) {\n                    const emaData = calculateEMA(data, 200);\n                    if (emaData.length > 0) {\n                        ema200SeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            color: 'rgba(138, 43, 226, 0.8)',\n                            lineWidth: 2\n                        });\n                        ema200SeriesRef.current.setData(emaData);\n                    }\n                }\n                if (visibleIndicators.includes('psar')) {\n                    const psarData = calculateParabolicSAR(data);\n                    if (psarData.length > 0) {\n                        parabolicSARSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            color: 'rgba(255, 165, 0, 0.8)',\n                            lineWidth: 2,\n                            lineStyle: lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineStyle.Dotted,\n                            crosshairMarkerVisible: false\n                        });\n                        parabolicSARSeriesRef.current.setData(psarData);\n                    }\n                }\n                if (visibleIndicators.includes('bollinger')) {\n                    const { upper, middle, lower } = calculateBollingerBands(data);\n                    const commonBBLineOptions = {\n                        lineWidth: 1,\n                        lastValueVisible: false,\n                        priceLineVisible: false\n                    };\n                    if (upper.length > 0) {\n                        bbUpperRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            ...commonBBLineOptions,\n                            color: 'rgba(33, 150, 243, 0.5)'\n                        });\n                        bbUpperRef.current.setData(upper);\n                    }\n                    if (middle.length > 0) {\n                        bbMiddleRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            ...commonBBLineOptions,\n                            color: 'rgba(255, 152, 0, 0.7)',\n                            lineStyle: lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineStyle.Dotted\n                        });\n                        bbMiddleRef.current.setData(middle);\n                    }\n                    if (lower.length > 0) {\n                        bbLowerRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                            ...commonBBLineOptions,\n                            color: 'rgba(33, 150, 243, 0.5)'\n                        });\n                        bbLowerRef.current.setData(lower);\n                    }\n                }\n            }\n        }\n    }[\"CandleChart.useEffect\"], [\n        data,\n        showIndicators,\n        visibleIndicators,\n        keyLevels\n    ]); // Re-run when data or showIndicators changes\n    // Cleanup chart instance on component unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CandleChart.useEffect\": ()=>{\n            return ({\n                \"CandleChart.useEffect\": ()=>{\n                    if (chartRef.current) {\n                        chartRef.current.remove();\n                        chartRef.current = null;\n                    }\n                }\n            })[\"CandleChart.useEffect\"];\n        }\n    }[\"CandleChart.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\DELL\\\\Desktop\\\\Projects\\\\project_tradeiq\\\\components\\\\CandleChart.tsx\",\n        lineNumber: 556,\n        columnNumber: 10\n    }, undefined);\n};\n_s(CandleChart, \"SnLnNNxZWhy0/aT4Ik3p597+2Uc=\");\n_c = CandleChart;\nvar _c;\n$RefreshReg$(_c, \"CandleChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2FuZGxlQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWlEO0FBWVY7QUFFdkMsZ0VBQWdFO0FBQ2hFLE1BQU1RLGVBQWUsQ0FBQ0MsTUFBK0JDO0lBQ25ELE1BQU1DLFVBQTRCLEVBQUU7SUFDcEMsSUFBSUYsS0FBS0csTUFBTSxHQUFHRixRQUFRLE9BQU9DO0lBRWpDLE1BQU1FLElBQUksSUFBS0gsQ0FBQUEsU0FBUztJQUN4QixzQkFBc0I7SUFDdEIsSUFBSUksWUFBWTtJQUNoQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsUUFBUUssSUFBSztRQUMvQkQsYUFBYUwsSUFBSSxDQUFDTSxFQUFFLENBQUNDLEtBQUs7SUFDNUI7SUFDQSxJQUFJQyxVQUFVSCxZQUFZSjtJQUMxQkMsUUFBUU8sSUFBSSxDQUFDO1FBQUVDLE1BQU1WLElBQUksQ0FBQ0MsU0FBUyxFQUFFLENBQUNTLElBQUk7UUFBRUMsT0FBT0g7SUFBUTtJQUUzRCxJQUFLLElBQUlGLElBQUlMLFFBQVFLLElBQUlOLEtBQUtHLE1BQU0sRUFBRUcsSUFBSztRQUN6QyxNQUFNTSxhQUFhLElBQUssQ0FBQ04sRUFBRSxDQUFDQyxLQUFLLEdBQUdILElBQU1JLFVBQVcsS0FBSUosQ0FBQUE7UUFDekRGLFFBQVFPLElBQUksQ0FBQztZQUFFQyxNQUFNVixJQUFJLENBQUNNLEVBQUUsQ0FBQ0ksSUFBSTtZQUFFQyxPQUFPQztRQUFXO1FBQ3JESixVQUFVSTtJQUNaO0lBQ0EsT0FBT1Y7QUFDVDtBQUVBLDZEQUE2RDtBQUM3RCxNQUFNVyxlQUFlLFNBQUNiO1FBQStCQywwRUFBaUI7SUFDcEUsTUFBTWEsVUFBNEIsRUFBRTtJQUNwQyxJQUFJQyxRQUFRO0lBQ1osSUFBSUMsU0FBUztJQUViLDZDQUE2QztJQUM3QyxJQUFLLElBQUlWLElBQUksR0FBR0EsS0FBS0wsUUFBUUssSUFBSztRQUNoQyxNQUFNVyxTQUFTakIsSUFB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Z0JBQ0Y7WUFDRjtRQUNGO2dDQUFHO1FBQUNwRTtRQUFNc0Y7UUFBZ0JDO1FBQW1CQztLQUFVLEdBQUcsNkNBQTZDO0lBRXZHLDhDQUE4QztJQUM5Q2hHLGdEQUFTQTtpQ0FBQztZQUNSO3lDQUFPO29CQUNMLElBQUlrRyxTQUFTZSxPQUFPLEVBQUU7d0JBQ3BCZixTQUFTZSxPQUFPLENBQUN3RSxNQUFNO3dCQUN2QnZGLFNBQVNlLE9BQU8sR0FBRztvQkFDckI7Z0JBQ0Y7O1FBQ0Y7Z0NBQUcsRUFBRTtJQUVMLHFCQUFPLDhEQUFDeUU7UUFBSUMsS0FBSzFGO1FBQW1CMkYsT0FBTztZQUFFMUUsT0FBTztZQUFRRSxRQUFRO1FBQU87Ozs7OztBQUM3RSxFQUFFO0dBcFJXdkI7S0FBQUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcUHJvamVjdHNcXHByb2plY3RfdHJhZGVpcVxcY29tcG9uZW50c1xcQ2FuZGxlQ2hhcnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlQ2hhcnQsXG4gIElDaGFydEFwaSxcbiAgSVNlcmllc0FwaSxcbiAgQ2FuZGxlc3RpY2tTZXJpZXMsXG4gIExpbmVTZXJpZXMsXG4gIENhbmRsZXN0aWNrRGF0YSxcbiAgTGluZURhdGEsXG4gIFRpbWUsXG4gIEhpc3RvZ3JhbVNlcmllcyxcbiAgSGlzdG9ncmFtRGF0YSxcbiAgTGluZVN0eWxlfSBmcm9tIFwibGlnaHR3ZWlnaHQtY2hhcnRzXCI7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgRXhwb25lbnRpYWwgTW92aW5nIEF2ZXJhZ2UgKEVNQSlcbmNvbnN0IGNhbGN1bGF0ZUVNQSA9IChkYXRhOiBDYW5kbGVzdGlja0RhdGE8VGltZT5bXSwgcGVyaW9kOiBudW1iZXIpOiBMaW5lRGF0YTxUaW1lPltdID0+IHtcbiAgY29uc3QgZW1hRGF0YTogTGluZURhdGE8VGltZT5bXSA9IFtdO1xuICBpZiAoZGF0YS5sZW5ndGggPCBwZXJpb2QpIHJldHVybiBlbWFEYXRhO1xuXG4gIGNvbnN0IGsgPSAyIC8gKHBlcmlvZCArIDEpO1xuICAvLyBGaXJzdCBFTUEgaXMgYW4gU01BXG4gIGxldCBzdW1Gb3JTbWEgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBlcmlvZDsgaSsrKSB7XG4gICAgc3VtRm9yU21hICs9IGRhdGFbaV0uY2xvc2U7XG4gIH1cbiAgbGV0IHByZXZFbWEgPSBzdW1Gb3JTbWEgLyBwZXJpb2Q7XG4gIGVtYURhdGEucHVzaCh7IHRpbWU6IGRhdGFbcGVyaW9kIC0gMV0udGltZSwgdmFsdWU6IHByZXZFbWEgfSk7XG5cbiAgZm9yIChsZXQgaSA9IHBlcmlvZDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50RW1hID0gKGRhdGFbaV0uY2xvc2UgKiBrKSArIChwcmV2RW1hICogKDEgLSBrKSk7XG4gICAgZW1hRGF0YS5wdXNoKHsgdGltZTogZGF0YVtpXS50aW1lLCB2YWx1ZTogY3VycmVudEVtYSB9KTtcbiAgICBwcmV2RW1hID0gY3VycmVudEVtYTtcbiAgfVxuICByZXR1cm4gZW1hRGF0YTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgUmVsYXRpdmUgU3RyZW5ndGggSW5kZXggKFJTSSlcbmNvbnN0IGNhbGN1bGF0ZVJTSSA9IChkYXRhOiBDYW5kbGVzdGlja0RhdGE8VGltZT5bXSwgcGVyaW9kOiBudW1iZXIgPSAxNCk6IExpbmVEYXRhPFRpbWU+W10gPT4ge1xuICBjb25zdCByc2lEYXRhOiBMaW5lRGF0YTxUaW1lPltdID0gW107XG4gIGxldCBnYWlucyA9IDA7XG4gIGxldCBsb3NzZXMgPSAwO1xuXG4gIC8vIENhbGN1bGF0ZSBpbml0aWFsIGF2ZXJhZ2UgZ2FpbnMgYW5kIGxvc3Nlc1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBwZXJpb2Q7IGkrKykge1xuICAgIGNvbnN0IGNoYW5nZSA9IGRhdGFbaV0uY2xvc2UgLSBkYXRhW2kgLSAxXS5jbG9zZTtcbiAgICBpZiAoY2hhbmdlID4gMCkge1xuICAgICAgZ2FpbnMgKz0gY2hhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb3NzZXMgLT0gY2hhbmdlOyAvLyBsb3NzZXMgYXJlIHBvc2l0aXZlXG4gICAgfVxuICB9XG5cbiAgbGV0IGF2Z0dhaW4gPSBnYWlucyAvIHBlcmlvZDtcbiAgbGV0IGF2Z0xvc3MgPSBsb3NzZXMgLyBwZXJpb2Q7XG5cbiAgaWYgKGF2Z0xvc3MgPT09IDApIHtcbiAgICByc2lEYXRhLnB1c2goeyB0aW1lOiBkYXRhW3BlcmlvZF0udGltZSwgdmFsdWU6IDEwMCB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBycyA9IGF2Z0dhaW4gLyBhdmdMb3NzO1xuICAgIHJzaURhdGEucHVzaCh7IHRpbWU6IGRhdGFbcGVyaW9kXS50aW1lLCB2YWx1ZTogMTAwIC0gMTAwIC8gKDEgKyBycykgfSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgc3Vic2VxdWVudCBSU0kgdmFsdWVzXG4gIGZvciAobGV0IGkgPSBwZXJpb2QgKyAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYW5nZSA9IGRhdGFbaV0uY2xvc2UgLSBkYXRhW2kgLSAxXS5jbG9zZTtcbiAgICBsZXQgY3VycmVudEdhaW4gPSAwO1xuICAgIGxldCBjdXJyZW50TG9zcyA9IDA7XG5cbiAgICBpZiAoY2hhbmdlID4gMCkge1xuICAgICAgY3VycmVudEdhaW4gPSBjaGFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRMb3NzID0gLWNoYW5nZTtcbiAgICB9XG5cbiAgICBhdmdHYWluID0gKGF2Z0dhaW4gKiAocGVyaW9kIC0gMSkgKyBjdXJyZW50R2FpbikgLyBwZXJpb2Q7XG4gICAgYXZnTG9zcyA9IChhdmdMb3NzICogKHBlcmlvZCAtIDEpICsgY3VycmVudExvc3MpIC8gcGVyaW9kO1xuXG4gICAgaWYgKGF2Z0xvc3MgPT09IDApIHtcbiAgICAgIHJzaURhdGEucHVzaCh7IHRpbWU6IGRhdGFbaV0udGltZSwgdmFsdWU6IDEwMCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcnMgPSBhdmdHYWluIC8gYXZnTG9zcztcbiAgICAgIHJzaURhdGEucHVzaCh7IHRpbWU6IGRhdGFbaV0udGltZSwgdmFsdWU6IDEwMCAtIDEwMCAvICgxICsgcnMpIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnNpRGF0YTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgUGFyYWJvbGljIFNBUiAoUFNBUilcbmNvbnN0IGNhbGN1bGF0ZVBhcmFib2xpY1NBUiA9IChcbiAgZGF0YTogQ2FuZGxlc3RpY2tEYXRhPFRpbWU+W10sXG4gIGluaXRpYWxBZjogbnVtYmVyID0gMC4wMixcbiAgaW5jcmVtZW50QWY6IG51bWJlciA9IDAuMDIsXG4gIG1heEFmOiBudW1iZXIgPSAwLjIwXG4pOiBMaW5lRGF0YTxUaW1lPltdID0+IHtcbiAgY29uc3QgcHNhckRhdGE6IExpbmVEYXRhPFRpbWU+W10gPSBbXTtcbiAgaWYgKGRhdGEubGVuZ3RoIDwgMikgcmV0dXJuIHBzYXJEYXRhO1xuXG4gIGxldCBpc0xvbmcgPSBkYXRhWzFdLmNsb3NlID4gZGF0YVswXS5jbG9zZTsgLy8gSW5pdGlhbCB0cmVuZCBndWVzc1xuICBsZXQgYWYgPSBpbml0aWFsQWY7XG4gIGxldCBleHRyZW1lUG9pbnQgPSBpc0xvbmcgPyBNYXRoLm1heChkYXRhWzBdLmhpZ2gsIGRhdGFbMV0uaGlnaCkgOiBNYXRoLm1pbihkYXRhWzBdLmxvdywgZGF0YVsxXS5sb3cpO1xuICBsZXQgc2FyID0gaXNMb25nID8gZGF0YVswXS5sb3cgOiBkYXRhWzBdLmhpZ2g7XG5cbiAgLy8gRmlyc3QgcG9pbnQgKG9yIGZpcnN0IGNhbGN1bGFibGUgcG9pbnQpXG4gIC8vIFRoZSBmaXJzdCBTQVIgcG9pbnQgaXMgdHlwaWNhbGx5IHRoZSBwcmlvciBFUCAoaGlnaCBmb3Igc2hvcnQsIGxvdyBmb3IgbG9uZylcbiAgLy8gRm9yIHNpbXBsaWNpdHksIHdlIHN0YXJ0IGNhbGN1bGF0aW5nIFNBUiBmcm9tIHRoZSBzZWNvbmQgYmFyLCB1c2luZyB0aGUgZmlyc3QgYmFyJ3MgZGF0YSBmb3IgaW5pdGlhbCBFUC9TQVIuXG4gIC8vIFNvbWUgaW1wbGVtZW50YXRpb25zIG1pZ2h0IHNraXAgdGhlIGZpcnN0IGZldyBiYXJzIG9yIHVzZSBkaWZmZXJlbnQgaW5pdGlhbGl6YXRpb24uXG4gIHBzYXJEYXRhLnB1c2goeyB0aW1lOiBkYXRhWzBdLnRpbWUsIHZhbHVlOiBzYXIgfSk7IFxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXZTYXIgPSBzYXI7XG4gICAgY29uc3QgcHJldkFmID0gYWY7XG4gICAgY29uc3QgcHJldkV4dHJlbWVQb2ludCA9IGV4dHJlbWVQb2ludDtcblxuICAgIGlmIChpc0xvbmcpIHtcbiAgICAgIHNhciA9IHByZXZTYXIgKyBwcmV2QWYgKiAocHJldkV4dHJlbWVQb2ludCAtIHByZXZTYXIpO1xuICAgICAgaWYgKGRhdGFbaV0ubG93IDwgc2FyKSB7IC8vIFN3aXRjaCB0byBzaG9ydFxuICAgICAgICBpc0xvbmcgPSBmYWxzZTtcbiAgICAgICAgc2FyID0gcHJldkV4dHJlbWVQb2ludDsgLy8gU0FSIGJlY29tZXMgdGhlIGhpZ2hlc3QgcG9pbnQgb2YgdGhlIHByZXZpb3VzIHVwdHJlbmRcbiAgICAgICAgZXh0cmVtZVBvaW50ID0gZGF0YVtpXS5sb3c7XG4gICAgICAgIGFmID0gaW5pdGlhbEFmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGFbaV0uaGlnaCA+IHByZXZFeHRyZW1lUG9pbnQpIHtcbiAgICAgICAgICBleHRyZW1lUG9pbnQgPSBkYXRhW2ldLmhpZ2g7XG4gICAgICAgICAgYWYgPSBNYXRoLm1pbihtYXhBZiwgcHJldkFmICsgaW5jcmVtZW50QWYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gaXNTaG9ydFxuICAgICAgc2FyID0gcHJldlNhciAtIHByZXZBZiAqIChwcmV2U2FyIC0gcHJldkV4dHJlbWVQb2ludCk7XG4gICAgICBpZiAoZGF0YVtpXS5oaWdoID4gc2FyKSB7IC8vIFN3aXRjaCB0byBsb25nXG4gICAgICAgIGlzTG9uZyA9IHRydWU7XG4gICAgICAgIHNhciA9IHByZXZFeHRyZW1lUG9pbnQ7IC8vIFNBUiBiZWNvbWVzIHRoZSBsb3dlc3QgcG9pbnQgb2YgdGhlIHByZXZpb3VzIGRvd250cmVuZFxuICAgICAgICBleHRyZW1lUG9pbnQgPSBkYXRhW2ldLmhpZ2g7XG4gICAgICAgIGFmID0gaW5pdGlhbEFmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGFbaV0ubG93IDwgcHJldkV4dHJlbWVQb2ludCkge1xuICAgICAgICAgIGV4dHJlbWVQb2ludCA9IGRhdGFbaV0ubG93O1xuICAgICAgICAgIGFmID0gTWF0aC5taW4obWF4QWYsIHByZXZBZiArIGluY3JlbWVudEFmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbnN1cmUgU0FSIGRvZXMgbm90IGNyb3NzIHRoZSBwcmV2aW91cyBvciBjdXJyZW50IHBlcmlvZCdzIGhpZ2gvbG93IHRvbyBhZ2dyZXNzaXZlbHlcbiAgICBpZiAoaXNMb25nKSB7XG4gICAgICAgIHNhciA9IE1hdGgubWluKHNhciwgZGF0YVtpLTFdLmxvdywgKGkgPiAxID8gZGF0YVtpLTJdLmxvdyA6IGRhdGFbaS0xXS5sb3cpKTtcbiAgICAgICAgaWYgKGRhdGFbaV0ubG93IDwgc2FyKSBzYXIgPSBkYXRhW2ldLmxvdzsgLy8gQWRkaXRpb25hbCBjaGVjayBpZiBTQVIgaXMgYnJva2VuIGludHJhZGF5XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2FyID0gTWF0aC5tYXgoc2FyLCBkYXRhW2ktMV0uaGlnaCwgKGkgPiAxID8gZGF0YVtpLTJdLmhpZ2ggOiBkYXRhW2ktMV0uaGlnaCkpO1xuICAgICAgICBpZiAoZGF0YVtpXS5oaWdoID4gc2FyKSBzYXIgPSBkYXRhW2ldLmhpZ2g7IC8vIEFkZGl0aW9uYWwgY2hlY2tcbiAgICB9XG5cbiAgICBwc2FyRGF0YS5wdXNoKHsgdGltZTogZGF0YVtpXS50aW1lLCB2YWx1ZTogc2FyIH0pO1xuICB9XG4gIHJldHVybiBwc2FyRGF0YTtcbn07XG5cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBNQUNEXG5pbnRlcmZhY2UgTUFDRE91dHB1dCB7XG4gIG1hY2RMaW5lOiBMaW5lRGF0YTxUaW1lPltdO1xuICBzaWduYWxMaW5lOiBMaW5lRGF0YTxUaW1lPltdO1xuICBoaXN0b2dyYW06IEhpc3RvZ3JhbURhdGE8VGltZT5bXTtcbn1cblxuY29uc3QgY2FsY3VsYXRlTUFDRCA9IChcbiAgZGF0YTogQ2FuZGxlc3RpY2tEYXRhPFRpbWU+W10sXG4gIGZhc3RQZXJpb2Q6IG51bWJlciA9IDEyLFxuICBzbG93UGVyaW9kOiBudW1iZXIgPSAyNixcbiAgc2lnbmFsUGVyaW9kOiBudW1iZXIgPSA5XG4pOiBNQUNET3V0cHV0ID0+IHtcbiAgY29uc3QgbWFjZExpbmU6IExpbmVEYXRhPFRpbWU+W10gPSBbXTtcbiAgY29uc3Qgc2lnbmFsTGluZTogTGluZURhdGE8VGltZT5bXSA9IFtdO1xuICBjb25zdCBoaXN0b2dyYW06IEhpc3RvZ3JhbURhdGE8VGltZT5bXSA9IFtdO1xuXG4gIGlmIChkYXRhLmxlbmd0aCA8IHNsb3dQZXJpb2QpIHJldHVybiB7IG1hY2RMaW5lLCBzaWduYWxMaW5lLCBoaXN0b2dyYW0gfTtcblxuICBjb25zdCBmYXN0RU1BQ2FsYyA9IGNhbGN1bGF0ZUVNQShkYXRhLCBmYXN0UGVyaW9kKTtcbiAgY29uc3Qgc2xvd0VNQUNhbGMgPSBjYWxjdWxhdGVFTUEoZGF0YSwgc2xvd1BlcmlvZCk7XG5cbiAgLy8gQWxpZ24gRU1BcyBhbmQgY2FsY3VsYXRlIE1BQ0QgbGluZVxuICAvLyBFTUFzIG1pZ2h0IGhhdmUgZGlmZmVyZW50IHN0YXJ0aW5nIHBvaW50cywgc28gd2UgbmVlZCB0byBhbGlnbiB0aGVtIGJ5IHRpbWVcbiAgY29uc3QgYWxpZ25lZE1hY2RWYWx1ZXM6IHsgdGltZTogVGltZTsgdmFsdWU6IG51bWJlciB9W10gPSBbXTtcbiAgbGV0IHNsb3dJZHggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZhc3RFTUFDYWxjLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmFzdFBvaW50ID0gZmFzdEVNQUNhbGNbaV07XG4gICAgd2hpbGUgKHNsb3dJZHggPCBzbG93RU1BQ2FsYy5sZW5ndGggJiYgc2xvd0VNQUNhbGNbc2xvd0lkeF0udGltZSA8IGZhc3RQb2ludC50aW1lKSB7XG4gICAgICBzbG93SWR4Kys7XG4gICAgfVxuICAgIGlmIChzbG93SWR4IDwgc2xvd0VNQUNhbGMubGVuZ3RoICYmIHNsb3dFTUFDYWxjW3Nsb3dJZHhdLnRpbWUgPT09IGZhc3RQb2ludC50aW1lKSB7XG4gICAgICBjb25zdCBtYWNkVmFsdWUgPSBmYXN0UG9pbnQudmFsdWUgLSBzbG93RU1BQ2FsY1tzbG93SWR4XS52YWx1ZTtcbiAgICAgIG1hY2RMaW5lLnB1c2goeyB0aW1lOiBmYXN0UG9pbnQudGltZSwgdmFsdWU6IG1hY2RWYWx1ZSB9KTtcbiAgICAgIGFsaWduZWRNYWNkVmFsdWVzLnB1c2goeyB0aW1lOiBmYXN0UG9pbnQudGltZSwgdmFsdWU6IG1hY2RWYWx1ZSB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoYWxpZ25lZE1hY2RWYWx1ZXMubGVuZ3RoIDwgc2lnbmFsUGVyaW9kKSByZXR1cm4geyBtYWNkTGluZSwgc2lnbmFsTGluZSwgaGlzdG9ncmFtIH07XG5cbiAgLy8gQ2FsY3VsYXRlIFNpZ25hbCBsaW5lIChFTUEgb2YgTUFDRCBsaW5lKVxuICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgTUFDRCB2YWx1ZXMgdG8gQ2FuZGxlc3RpY2tEYXRhLWxpa2Ugc3RydWN0dXJlIGZvciBjYWxjdWxhdGVFTUFcbiAgY29uc3QgbWFjZEZvclNpZ25hbEVNQTogQ2FuZGxlc3RpY2tEYXRhPFRpbWU+W10gPSBhbGlnbmVkTWFjZFZhbHVlcy5tYXAocCA9PiAoeyB0aW1lOiBwLnRpbWUsIG9wZW46IHAudmFsdWUsIGhpZ2g6IHAudmFsdWUsIGxvdzogcC52YWx1ZSwgY2xvc2U6IHAudmFsdWUgfSkpO1xuICBjb25zdCBzaWduYWxMaW5lQ2FsYyA9IGNhbGN1bGF0ZUVNQShtYWNkRm9yU2lnbmFsRU1BLCBzaWduYWxQZXJpb2QpO1xuICBzaWduYWxMaW5lLnB1c2goLi4uc2lnbmFsTGluZUNhbGMpO1xuICBcbiAgLy8gQWxpZ24gTUFDRCBhbmQgU2lnbmFsIGxpbmVzIGFuZCBjYWxjdWxhdGUgSGlzdG9ncmFtXG4gIGxldCBzaWduYWxJZHggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hY2RMaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWFjZFBvaW50ID0gbWFjZExpbmVbaV07XG4gICAgd2hpbGUgKHNpZ25hbElkeCA8IHNpZ25hbExpbmUubGVuZ3RoICYmIHNpZ25hbExpbmVbc2lnbmFsSWR4XS50aW1lIDwgbWFjZFBvaW50LnRpbWUpIHtcbiAgICAgIHNpZ25hbElkeCsrO1xuICAgIH1cbiAgICBpZiAoc2lnbmFsSWR4IDwgc2lnbmFsTGluZS5sZW5ndGggJiYgc2lnbmFsTGluZVtzaWduYWxJZHhdLnRpbWUgPT09IG1hY2RQb2ludC50aW1lKSB7XG4gICAgICBjb25zdCBoaXN0VmFsdWUgPSBtYWNkUG9pbnQudmFsdWUgLSBzaWduYWxMaW5lW3NpZ25hbElkeF0udmFsdWU7XG4gICAgICBoaXN0b2dyYW0ucHVzaCh7IHRpbWU6IG1hY2RQb2ludC50aW1lLCB2YWx1ZTogaGlzdFZhbHVlLCBjb2xvcjogaGlzdFZhbHVlID49IDAgPyAncmdiYSgwLCAxNTAsIDEzNiwgMC44KScgOiAncmdiYSgyNTUsIDgyLCA4MiwgMC44KScgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgbWFjZExpbmUsIHNpZ25hbExpbmUsIGhpc3RvZ3JhbSB9O1xufTtcblxuXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgQm9sbGluZ2VyIEJhbmRzXG5mdW5jdGlvbiBjYWxjdWxhdGVCb2xsaW5nZXJCYW5kcyhcbiAgZGF0YTogQ2FuZGxlc3RpY2tEYXRhPFRpbWU+W10sXG4gIHBlcmlvZCA9IDIwLFxuICBrID0gMiAvLyBTdGFuZGFyZCBkZXZpYXRpb25zXG4pOiB7XG4gIHVwcGVyOiBMaW5lRGF0YTxUaW1lPltdO1xuICBtaWRkbGU6IExpbmVEYXRhPFRpbWU+W107XG4gIGxvd2VyOiBMaW5lRGF0YTxUaW1lPltdO1xufSB7XG4gIGNvbnN0IHVwcGVyRGF0YTogTGluZURhdGE8VGltZT5bXSA9IFtdO1xuICBjb25zdCBtaWRkbGVEYXRhOiBMaW5lRGF0YTxUaW1lPltdID0gW107XG4gIGNvbnN0IGxvd2VyRGF0YTogTGluZURhdGE8VGltZT5bXSA9IFtdO1xuXG4gIGlmIChkYXRhLmxlbmd0aCA8IHBlcmlvZCkge1xuICAgIHJldHVybiB7IHVwcGVyOiB1cHBlckRhdGEsIG1pZGRsZTogbWlkZGxlRGF0YSwgbG93ZXI6IGxvd2VyRGF0YSB9O1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IHBlcmlvZCAtIDE7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFNsaWNlID0gZGF0YS5zbGljZShpIC0gcGVyaW9kICsgMSwgaSArIDEpO1xuICAgIGNvbnN0IGNsb3NlcyA9IGN1cnJlbnRTbGljZS5tYXAoZCA9PiBkLmNsb3NlKTtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IGRhdGFbaV0udGltZTtcblxuICAgIGNvbnN0IHNtYSA9IGNsb3Nlcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApIC8gcGVyaW9kO1xuICAgIGlmIChpc05hTihzbWEpKSBjb250aW51ZTsgLy8gU2tpcCBpZiBTTUEgaXMgbm90IGEgbnVtYmVyXG5cbiAgICBtaWRkbGVEYXRhLnB1c2goeyB0aW1lOiBjdXJyZW50VGltZSwgdmFsdWU6IHNtYSB9KTtcblxuICAgIGxldCB2YXJpYW5jZSA9IDA7XG4gICAgZm9yIChjb25zdCBjbG9zZSBvZiBjbG9zZXMpIHtcbiAgICAgIHZhcmlhbmNlICs9IE1hdGgucG93KGNsb3NlIC0gc21hLCAyKTtcbiAgICB9XG4gICAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlIC8gcGVyaW9kKTtcblxuICAgIGNvbnN0IHVwcGVyQmFuZFZhbHVlID0gc21hICsgayAqIHN0ZERldjtcbiAgICBpZiAoIWlzTmFOKHVwcGVyQmFuZFZhbHVlKSkge1xuICAgICAgdXBwZXJEYXRhLnB1c2goeyB0aW1lOiBjdXJyZW50VGltZSwgdmFsdWU6IHVwcGVyQmFuZFZhbHVlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxvd2VyQmFuZFZhbHVlID0gc21hIC0gayAqIHN0ZERldjtcbiAgICBpZiAoIWlzTmFOKGxvd2VyQmFuZFZhbHVlKSkge1xuICAgICAgbG93ZXJEYXRhLnB1c2goeyB0aW1lOiBjdXJyZW50VGltZSwgdmFsdWU6IGxvd2VyQmFuZFZhbHVlIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB1cHBlcjogdXBwZXJEYXRhLCBtaWRkbGU6IG1pZGRsZURhdGEsIGxvd2VyOiBsb3dlckRhdGEgfTtcbn1cblxuZXhwb3J0IHR5cGUgSW5kaWNhdG9yVHlwZSA9ICdyc2knIHwgJ21hY2QnIHwgJ2VtYTIxJyB8ICdlbWE1MCcgfCAnZW1hMjAwJyB8ICdwc2FyJyB8ICdib2xsaW5nZXInO1xuXG5pbnRlcmZhY2UgS2V5TGV2ZWxzIHtcbiAgc3VwcG9ydDogbnVtYmVyIHwgbnVsbDtcbiAgcmVzaXN0YW5jZTogbnVtYmVyIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIENhbmRsZUNoYXJ0UHJvcHMge1xuICBkYXRhOiBDYW5kbGVzdGlja0RhdGE8VGltZT5bXTtcbiAgc2hvd0luZGljYXRvcnM/OiBib29sZWFuO1xuICB2aXNpYmxlSW5kaWNhdG9ycz86IEluZGljYXRvclR5cGVbXTtcbiAga2V5TGV2ZWxzPzogS2V5TGV2ZWxzO1xufVxuXG5leHBvcnQgY29uc3QgQ2FuZGxlQ2hhcnQ6IFJlYWN0LkZDPENhbmRsZUNoYXJ0UHJvcHM+ID0gKHsgZGF0YSwgc2hvd0luZGljYXRvcnMgPSBmYWxzZSwgdmlzaWJsZUluZGljYXRvcnMgPSBbXSwga2V5TGV2ZWxzIH0pID0+IHtcbiAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxJQ2hhcnRBcGkgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuZGxlc3RpY2tTZXJpZXNSZWYgPSB1c2VSZWY8SVNlcmllc0FwaTwnQ2FuZGxlc3RpY2snPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCByc2lTZXJpZXNSZWYgPSB1c2VSZWY8SVNlcmllc0FwaTwnTGluZSc+IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IG1hY2RMaW5lU2VyaWVzUmVmID0gdXNlUmVmPElTZXJpZXNBcGk8J0xpbmUnPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBtYWNkU2lnbmFsU2VyaWVzUmVmID0gdXNlUmVmPElTZXJpZXNBcGk8J0xpbmUnPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBtYWNkSGlzdG9ncmFtU2VyaWVzUmVmID0gdXNlUmVmPElTZXJpZXNBcGk8J0hpc3RvZ3JhbSc+IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGVtYTIxU2VyaWVzUmVmID0gdXNlUmVmPElTZXJpZXNBcGk8J0xpbmUnPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBlbWE1MFNlcmllc1JlZiA9IHVzZVJlZjxJU2VyaWVzQXBpPCdMaW5lJz4gfCBudWxsPihudWxsKTtcbiAgY29uc3QgZW1hMjAwU2VyaWVzUmVmID0gdXNlUmVmPElTZXJpZXNBcGk8J0xpbmUnPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBwYXJhYm9saWNTQVJTZXJpZXNSZWYgPSB1c2VSZWY8SVNlcmllc0FwaTwnTGluZSc+IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGJiVXBwZXJSZWYgPSB1c2VSZWY8SVNlcmllc0FwaTwnTGluZSc+IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGJiTWlkZGxlUmVmID0gdXNlUmVmPElTZXJpZXNBcGk8J0xpbmUnPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBiYkxvd2VyUmVmID0gdXNlUmVmPElTZXJpZXNBcGk8J0xpbmUnPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzdXBwb3J0TGluZVJlZiA9IHVzZVJlZjxhbnkgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVzaXN0YW5jZUxpbmVSZWYgPSB1c2VSZWY8YW55IHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIEluaXRpYWxpemUgY2hhcnRcbiAgICBpZiAoIWNoYXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjcmVhdGVDaGFydChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LCB7XG4gICAgICAgIHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnI2ZmZmZmZicgfSxcbiAgICAgICAgICB0ZXh0Q29sb3I6ICcjMzMzJyxcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHZlcnRMaW5lczogeyBjb2xvcjogJyNlMWUxZTEnIH0sXG4gICAgICAgICAgaG9yekxpbmVzOiB7IGNvbG9yOiAnI2UxZTFlMScgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGltZVNjYWxlOiB7XG4gICAgICAgICAgcmlnaHRPZmZzZXQ6IDE1LCAvLyBOdW1iZXIgb2YgYmFycyBmb3IgcGFkZGluZ1xuICAgICAgICAgIGJhclNwYWNpbmc6IDgsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcjY2NjY2NjJyxcbiAgICAgICAgICB0aW1lVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICBzZWNvbmRzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIERlZmluZSBhIHNlcGFyYXRlIHByaWNlIHNjYWxlIGZvciBSU0kgaWYgbmVlZGVkLCBvciBsZXQgaXQgYXV0by1jcmVhdGVcbiAgICAgICAgLy8gRXhhbXBsZTogbGVmdFByaWNlU2NhbGU6IHsgdmlzaWJsZTogdHJ1ZSwgbW9kZTogUHJpY2VTY2FsZU1vZGUuTm9ybWFsIH0sIFxuICAgICAgICAvLyBXZSB3aWxsIHRyeSB0byBhdHRhY2ggUlNJIHRvIGEgbmV3IHBhbmUgdXNpbmcgcHJpY2VTY2FsZUlkOiAnJyBvciAncnNpJ1xuICAgICAgfSk7XG4gICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ID0gY2hhcnRSZWYuY3VycmVudC5hZGRTZXJpZXMoQ2FuZGxlc3RpY2tTZXJpZXMsIHtcbiAgICAgICAgdXBDb2xvcjogJyMyNmE2OWEnLCBcbiAgICAgICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsIFxuICAgICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgd2lja1VwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICAgICAgd2lja0Rvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGNhbmRsZXN0aWNrIGRhdGFcbiAgICBpZiAoY2hhcnRSZWYuY3VycmVudCAmJiBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50ICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKGRhdGEpO1xuXG4gICAgICAvLyBTZXQgYSBkZWZhdWx0IHZpc2libGUgcmFuZ2UgdG8gc2hvdyB0aGUgbGFzdCA3MCBjYW5kbGVzIHdpdGggcGFkZGluZ1xuICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgaWYgKGRhdGFMZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IFBBRERJTkdfQkFSUyA9IDAgLy8gTWF0Y2ggdGhpcyB3aXRoIHRpbWVTY2FsZS5yaWdodE9mZnNldCBpZiBkZXNpcmVkXG4gICAgICAgIGNvbnN0IGxvZ2ljYWxGcm9tID0gTWF0aC5tYXgoMCwgZGF0YUxlbmd0aCAtIDUwKTsgLy8gU2hvdyBsYXRlc3QgNzAgZGF0YSBwb2ludHNcbiAgICAgICAgY29uc3QgbG9naWNhbFRvID0gKGRhdGFMZW5ndGggLSAxKSArIFBBRERJTkdfQkFSUzsgLy8gRXh0ZW5kIHJhbmdlIGJ5IFBBRERJTkdfQkFSUyBiZXlvbmQgdGhlIGxhc3QgZGF0YSBwb2ludFxuICAgICAgICBjaGFydFJlZi5jdXJyZW50LnRpbWVTY2FsZSgpLnNldFZpc2libGVMb2dpY2FsUmFuZ2UoeyBmcm9tOiBsb2dpY2FsRnJvbSwgdG86IGxvZ2ljYWxUbyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQuc2V0RGF0YShbXSk7IC8vIENsZWFyIGRhdGEgaWYgYGRhdGFgIHByb3AgaXMgZW1wdHlcbiAgICB9XG4gICAgXG4gICAgLy8gUmVzaXplIG9ic2VydmVyXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMCB8fCBlbnRyaWVzWzBdLnRhcmdldCAhPT0gY2hhcnRDb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudD8uYXBwbHlPcHRpb25zKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICB9KTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIC8vIENoYXJ0IHJlbW92YWwgaXMgaGFuZGxlZCBpbiB0aGUgaW5kaWNhdG9yIGVmZmVjdCdzIGNsZWFudXAgaWYgc2hvd0luZGljYXRvcnMgY2hhbmdlc1xuICAgICAgLy8gT3IgaGVyZSBpZiB0aGUgY29tcG9uZW50IHVubW91bnRzIGVudGlyZWx5LlxuICAgICAgLy8gSWYgd2Ugb25seSByZW1vdmUgc2VyaWVzLCB0aGUgY2hhcnQgaW5zdGFuY2UgY2FuIHBlcnNpc3QuXG4gICAgfTtcbiAgfSwgW2RhdGFdKTsgLy8gT25seSByZS1ydW4gaWYgZGF0YSBjaGFuZ2VzLiBDaGFydCBjcmVhdGlvbiBpcyBvbmNlLlxuXG4gIC8vIEVmZmVjdCBmb3IgaGFuZGxpbmcgaW5kaWNhdG9yc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcnRSZWYuY3VycmVudCB8fCAhY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA8IDIwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSBjaGFydFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHNlcmllcyA9IGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQ7XG5cbiAgICAvLyBDbGVhciBhbmQgZHJhdyBrZXkgbGV2ZWwgbGluZXNcbiAgICBpZiAoc3VwcG9ydExpbmVSZWYuY3VycmVudCkge1xuICAgICAgc2VyaWVzLnJlbW92ZVByaWNlTGluZShzdXBwb3J0TGluZVJlZi5jdXJyZW50KTtcbiAgICAgIHN1cHBvcnRMaW5lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzaXN0YW5jZUxpbmVSZWYuY3VycmVudCkge1xuICAgICAgc2VyaWVzLnJlbW92ZVByaWNlTGluZShyZXNpc3RhbmNlTGluZVJlZi5jdXJyZW50KTtcbiAgICAgIHJlc2lzdGFuY2VMaW5lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChrZXlMZXZlbHM/LnN1cHBvcnQpIHtcbiAgICAgIHN1cHBvcnRMaW5lUmVmLmN1cnJlbnQgPSBzZXJpZXMuY3JlYXRlUHJpY2VMaW5lKHtcbiAgICAgICAgcHJpY2U6IGtleUxldmVscy5zdXBwb3J0LFxuICAgICAgICBjb2xvcjogJyNlZjQ0NDQnLCAvLyByZWQtNTAwXG4gICAgICAgIGxpbmVXaWR0aDogMyxcbiAgICAgICAgbGluZVN0eWxlOiBMaW5lU3R5bGUuRGFzaGVkLFxuICAgICAgICBheGlzTGFiZWxWaXNpYmxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJycsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoa2V5TGV2ZWxzPy5yZXNpc3RhbmNlKSB7XG4gICAgICByZXNpc3RhbmNlTGluZVJlZi5jdXJyZW50ID0gc2VyaWVzLmNyZWF0ZVByaWNlTGluZSh7XG4gICAgICAgIHByaWNlOiBrZXlMZXZlbHMucmVzaXN0YW5jZSxcbiAgICAgICAgY29sb3I6ICcjZWY0NDQ0JywgLy8gcmVkLTUwMFxuICAgICAgICBsaW5lV2lkdGg6IDMsXG4gICAgICAgIGxpbmVTdHlsZTogTGluZVN0eWxlLkRhc2hlZCxcbiAgICAgICAgYXhpc0xhYmVsVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVtb3ZlU2VyaWVzID0gKHNlcmllc1JlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxJU2VyaWVzQXBpPGFueT4gfCBudWxsPikgPT4ge1xuICAgICAgaWYgKHNlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhcnQucmVtb3ZlU2VyaWVzKHNlcmllc1JlZi5jdXJyZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byByZW1vdmUgc2VyaWVzOlwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENsZWFyIGFsbCBpbmRpY2F0b3JzIGJlZm9yZSByZWRyYXdpbmdcbiAgICByZW1vdmVTZXJpZXMocnNpU2VyaWVzUmVmKTtcbiAgICByZW1vdmVTZXJpZXMobWFjZExpbmVTZXJpZXNSZWYpO1xuICAgIHJlbW92ZVNlcmllcyhtYWNkU2lnbmFsU2VyaWVzUmVmKTtcbiAgICByZW1vdmVTZXJpZXMobWFjZEhpc3RvZ3JhbVNlcmllc1JlZik7XG4gICAgcmVtb3ZlU2VyaWVzKGVtYTIxU2VyaWVzUmVmKTtcbiAgICByZW1vdmVTZXJpZXMoZW1hNTBTZXJpZXNSZWYpO1xuICAgIHJlbW92ZVNlcmllcyhlbWEyMDBTZXJpZXNSZWYpO1xuICAgIHJlbW92ZVNlcmllcyhwYXJhYm9saWNTQVJTZXJpZXNSZWYpO1xuICAgIHJlbW92ZVNlcmllcyhiYlVwcGVyUmVmKTtcbiAgICByZW1vdmVTZXJpZXMoYmJNaWRkbGVSZWYpO1xuICAgIHJlbW92ZVNlcmllcyhiYkxvd2VyUmVmKTtcblxuICAgIGlmIChzaG93SW5kaWNhdG9ycykge1xuICAgICAgaWYgKHZpc2libGVJbmRpY2F0b3JzLmluY2x1ZGVzKCdyc2knKSkge1xuICAgICAgICBjb25zdCByc2lEYXRhID0gY2FsY3VsYXRlUlNJKGRhdGEsIDE0KTtcbiAgICAgICAgaWYgKHJzaURhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJzaVNlcmllc1JlZi5jdXJyZW50ID0gY2hhcnQuYWRkU2VyaWVzKExpbmVTZXJpZXMsIHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgxMjgsIDAsIDEyOCwgMC44KScsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBwcmljZVNjYWxlSWQ6ICcnLCAvLyBOZXcgcGFuZVxuICAgICAgICAgICAgYXV0b3NjYWxlSW5mb1Byb3ZpZGVyOiAoKSA9PiAoeyBwcmljZVJhbmdlOiB7IG1pblZhbHVlOiAwLCBtYXhWYWx1ZTogMTAwIH0gfSksXG4gICAgICAgICAgICBsYXN0VmFsdWVWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgcHJpY2VMaW5lVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByc2lTZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKHJzaURhdGEpO1xuICAgICAgICAgIGNoYXJ0LnByaWNlU2NhbGUoJycpLmFwcGx5T3B0aW9ucyh7IHNjYWxlTWFyZ2luczogeyB0b3A6IDAuOCwgYm90dG9tOiAwIH0gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZpc2libGVJbmRpY2F0b3JzLmluY2x1ZGVzKCdtYWNkJykpIHtcbiAgICAgICAgY29uc3QgeyBtYWNkTGluZSwgc2lnbmFsTGluZSwgaGlzdG9ncmFtIH0gPSBjYWxjdWxhdGVNQUNEKGRhdGEpO1xuICAgICAgICBjb25zdCBtYWNkUGFuZUlkID0gJ21hY2RQYW5lJztcbiAgICAgICAgaWYgKG1hY2RMaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBtYWNkTGluZVNlcmllc1JlZi5jdXJyZW50ID0gY2hhcnQuYWRkU2VyaWVzKExpbmVTZXJpZXMsIHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAxMjAsIDI1NSwgMC44KScsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBwcmljZVNjYWxlSWQ6IG1hY2RQYW5lSWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFjZExpbmVTZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKG1hY2RMaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmFsTGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbWFjZFNpZ25hbFNlcmllc1JlZi5jdXJyZW50ID0gY2hhcnQuYWRkU2VyaWVzKExpbmVTZXJpZXMsIHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDEwMCwgMCwgMC44KScsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBwcmljZVNjYWxlSWQ6IG1hY2RQYW5lSWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFjZFNpZ25hbFNlcmllc1JlZi5jdXJyZW50LnNldERhdGEoc2lnbmFsTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpc3RvZ3JhbS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbWFjZEhpc3RvZ3JhbVNlcmllc1JlZi5jdXJyZW50ID0gY2hhcnQuYWRkU2VyaWVzKEhpc3RvZ3JhbVNlcmllcywge1xuICAgICAgICAgICAgcHJpY2VTY2FsZUlkOiBtYWNkUGFuZUlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hY2RIaXN0b2dyYW1TZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKGhpc3RvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hY2RMaW5lLmxlbmd0aCA+IDAgfHwgc2lnbmFsTGluZS5sZW5ndGggPiAwIHx8IGhpc3RvZ3JhbS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2hhcnQucHJpY2VTY2FsZShtYWNkUGFuZUlkKS5hcHBseU9wdGlvbnMoeyBzY2FsZU1hcmdpbnM6IHsgdG9wOiAwLjcsIGJvdHRvbTogMCB9IH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2aXNpYmxlSW5kaWNhdG9ycy5pbmNsdWRlcygnZW1hMjEnKSkge1xuICAgICAgICBjb25zdCBlbWFEYXRhID0gY2FsY3VsYXRlRU1BKGRhdGEsIDIxKTtcbiAgICAgICAgaWYgKGVtYURhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVtYTIxU2VyaWVzUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRTZXJpZXMoTGluZVNlcmllcywge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDI1NSwgMjE1LCAwLCAwLjgpJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbWEyMVNlcmllc1JlZi5jdXJyZW50LnNldERhdGEoZW1hRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZpc2libGVJbmRpY2F0b3JzLmluY2x1ZGVzKCdlbWE1MCcpKSB7XG4gICAgICAgIGNvbnN0IGVtYURhdGEgPSBjYWxjdWxhdGVFTUEoZGF0YSwgNTApO1xuICAgICAgICBpZiAoZW1hRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZW1hNTBTZXJpZXNSZWYuY3VycmVudCA9IGNoYXJ0LmFkZFNlcmllcyhMaW5lU2VyaWVzLCB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYmEoMzAsIDE0NCwgMjU1LCAwLjgpJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbWE1MFNlcmllc1JlZi5jdXJyZW50LnNldERhdGEoZW1hRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZpc2libGVJbmRpY2F0b3JzLmluY2x1ZGVzKCdlbWEyMDAnKSkge1xuICAgICAgICBjb25zdCBlbWFEYXRhID0gY2FsY3VsYXRlRU1BKGRhdGEsIDIwMCk7XG4gICAgICAgIGlmIChlbWFEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbWEyMDBTZXJpZXNSZWYuY3VycmVudCA9IGNoYXJ0LmFkZFNlcmllcyhMaW5lU2VyaWVzLCB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTM4LCA0MywgMjI2LCAwLjgpJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbWEyMDBTZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKGVtYURhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2aXNpYmxlSW5kaWNhdG9ycy5pbmNsdWRlcygncHNhcicpKSB7XG4gICAgICAgIGNvbnN0IHBzYXJEYXRhID0gY2FsY3VsYXRlUGFyYWJvbGljU0FSKGRhdGEpO1xuICAgICAgICBpZiAocHNhckRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmFib2xpY1NBUlNlcmllc1JlZi5jdXJyZW50ID0gY2hhcnQuYWRkU2VyaWVzKExpbmVTZXJpZXMsIHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDE2NSwgMCwgMC44KScsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBsaW5lU3R5bGU6IExpbmVTdHlsZS5Eb3R0ZWQsXG4gICAgICAgICAgICBjcm9zc2hhaXJNYXJrZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXJhYm9saWNTQVJTZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKHBzYXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmlzaWJsZUluZGljYXRvcnMuaW5jbHVkZXMoJ2JvbGxpbmdlcicpKSB7XG4gICAgICAgIGNvbnN0IHsgdXBwZXIsIG1pZGRsZSwgbG93ZXIgfSA9IGNhbGN1bGF0ZUJvbGxpbmdlckJhbmRzKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1vbkJCTGluZU9wdGlvbnMgPSB7IGxpbmVXaWR0aDogMSwgbGFzdFZhbHVlVmlzaWJsZTogZmFsc2UsIHByaWNlTGluZVZpc2libGU6IGZhbHNlIH0gYXMgY29uc3Q7XG4gICAgICAgIGlmICh1cHBlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYmJVcHBlclJlZi5jdXJyZW50ID0gY2hhcnQuYWRkU2VyaWVzKExpbmVTZXJpZXMsIHsgLi4uY29tbW9uQkJMaW5lT3B0aW9ucywgY29sb3I6ICdyZ2JhKDMzLCAxNTAsIDI0MywgMC41KScgfSk7XG4gICAgICAgICAgYmJVcHBlclJlZi5jdXJyZW50LnNldERhdGEodXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWRkbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGJiTWlkZGxlUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRTZXJpZXMoTGluZVNlcmllcywgeyAuLi5jb21tb25CQkxpbmVPcHRpb25zLCBjb2xvcjogJ3JnYmEoMjU1LCAxNTIsIDAsIDAuNyknLCBsaW5lU3R5bGU6IExpbmVTdHlsZS5Eb3R0ZWQgfSk7XG4gICAgICAgICAgYmJNaWRkbGVSZWYuY3VycmVudC5zZXREYXRhKG1pZGRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBiYkxvd2VyUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRTZXJpZXMoTGluZVNlcmllcywgeyAuLi5jb21tb25CQkxpbmVPcHRpb25zLCBjb2xvcjogJ3JnYmEoMzMsIDE1MCwgMjQzLCAwLjUpJyB9KTtcbiAgICAgICAgICBiYkxvd2VyUmVmLmN1cnJlbnQuc2V0RGF0YShsb3dlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtkYXRhLCBzaG93SW5kaWNhdG9ycywgdmlzaWJsZUluZGljYXRvcnMsIGtleUxldmVsc10pOyAvLyBSZS1ydW4gd2hlbiBkYXRhIG9yIHNob3dJbmRpY2F0b3JzIGNoYW5nZXNcblxuICAvLyBDbGVhbnVwIGNoYXJ0IGluc3RhbmNlIG9uIGNvbXBvbmVudCB1bm1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4gPGRpdiByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfSBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfX0gLz47XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiY3JlYXRlQ2hhcnQiLCJDYW5kbGVzdGlja1NlcmllcyIsIkxpbmVTZXJpZXMiLCJIaXN0b2dyYW1TZXJpZXMiLCJMaW5lU3R5bGUiLCJjYWxjdWxhdGVFTUEiLCJkYXRhIiwicGVyaW9kIiwiZW1hRGF0YSIsImxlbmd0aCIsImsiLCJzdW1Gb3JTbWEiLCJpIiwiY2xvc2UiLCJwcmV2RW1hIiwicHVzaCIsInRpbWUiLCJ2YWx1ZSIsImN1cnJlbnRFbWEiLCJjYWxjdWxhdGVSU0kiLCJyc2lEYXRhIiwiZ2FpbnMiLCJsb3NzZXMiLCJjaGFuZ2UiLCJhdmdHYWluIiwiYXZnTG9zcyIsInJzIiwiY3VycmVudEdhaW4iLCJjdXJyZW50TG9zcyIsImNhbGN1bGF0ZVBhcmFib2xpY1NBUiIsImluaXRpYWxBZiIsImluY3JlbWVudEFmIiwibWF4QWYiLCJwc2FyRGF0YSIsImlzTG9uZyIsImFmIiwiZXh0cmVtZVBvaW50IiwiTWF0aCIsIm1heCIsImhpZ2giLCJtaW4iLCJsb3ciLCJzYXIiLCJwcmV2U2FyIiwicHJldkFmIiwicHJldkV4dHJlbWVQb2ludCIsImNhbGN1bGF0ZU1BQ0QiLCJmYXN0UGVyaW9kIiwic2xvd1BlcmlvZCIsInNpZ25hbFBlcmlvZCIsIm1hY2RMaW5lIiwic2lnbmFsTGluZSIsImhpc3RvZ3JhbSIsImZhc3RFTUFDYWxjIiwic2xvd0VNQUNhbGMiLCJhbGlnbmVkTWFjZFZhbHVlcyIsInNsb3dJZHgiLCJmYXN0UG9pbnQiLCJtYWNkVmFsdWUiLCJtYWNkRm9yU2lnbmFsRU1BIiwibWFwIiwicCIsIm9wZW4iLCJzaWduYWxMaW5lQ2FsYyIsInNpZ25hbElkeCIsIm1hY2RQb2ludCIsImhpc3RWYWx1ZSIsImNvbG9yIiwiY2FsY3VsYXRlQm9sbGluZ2VyQmFuZHMiLCJ1cHBlckRhdGEiLCJtaWRkbGVEYXRhIiwibG93ZXJEYXRhIiwidXBwZXIiLCJtaWRkbGUiLCJsb3dlciIsImN1cnJlbnRTbGljZSIsInNsaWNlIiwiY2xvc2VzIiwiZCIsImN1cnJlbnRUaW1lIiwic21hIiwicmVkdWNlIiwiYWNjIiwidmFsIiwiaXNOYU4iLCJ2YXJpYW5jZSIsInBvdyIsInN0ZERldiIsInNxcnQiLCJ1cHBlckJhbmRWYWx1ZSIsImxvd2VyQmFuZFZhbHVlIiwiQ2FuZGxlQ2hhcnQiLCJzaG93SW5kaWNhdG9ycyIsInZpc2libGVJbmRpY2F0b3JzIiwia2V5TGV2ZWxzIiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImNhbmRsZXN0aWNrU2VyaWVzUmVmIiwicnNpU2VyaWVzUmVmIiwibWFjZExpbmVTZXJpZXNSZWYiLCJtYWNkU2lnbmFsU2VyaWVzUmVmIiwibWFjZEhpc3RvZ3JhbVNlcmllc1JlZiIsImVtYTIxU2VyaWVzUmVmIiwiZW1hNTBTZXJpZXNSZWYiLCJlbWEyMDBTZXJpZXNSZWYiLCJwYXJhYm9saWNTQVJTZXJpZXNSZWYiLCJiYlVwcGVyUmVmIiwiYmJNaWRkbGVSZWYiLCJiYkxvd2VyUmVmIiwic3VwcG9ydExpbmVSZWYiLCJyZXNpc3RhbmNlTGluZVJlZiIsImN1cnJlbnQiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJ0aW1lU2NhbGUiLCJyaWdodE9mZnNldCIsImJhclNwYWNpbmciLCJib3JkZXJDb2xvciIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJhZGRTZXJpZXMiLCJ1cENvbG9yIiwiZG93bkNvbG9yIiwiYm9yZGVyVmlzaWJsZSIsIndpY2tVcENvbG9yIiwid2lja0Rvd25Db2xvciIsInNldERhdGEiLCJkYXRhTGVuZ3RoIiwiUEFERElOR19CQVJTIiwibG9naWNhbEZyb20iLCJsb2dpY2FsVG8iLCJzZXRWaXNpYmxlTG9naWNhbFJhbmdlIiwiZnJvbSIsInRvIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsImVudHJpZXMiLCJ0YXJnZXQiLCJjb250ZW50UmVjdCIsImFwcGx5T3B0aW9ucyIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiY2hhcnQiLCJzZXJpZXMiLCJyZW1vdmVQcmljZUxpbmUiLCJzdXBwb3J0IiwiY3JlYXRlUHJpY2VMaW5lIiwicHJpY2UiLCJsaW5lV2lkdGgiLCJsaW5lU3R5bGUiLCJEYXNoZWQiLCJheGlzTGFiZWxWaXNpYmxlIiwidGl0bGUiLCJyZXNpc3RhbmNlIiwicmVtb3ZlU2VyaWVzIiwic2VyaWVzUmVmIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwiaW5jbHVkZXMiLCJwcmljZVNjYWxlSWQiLCJhdXRvc2NhbGVJbmZvUHJvdmlkZXIiLCJwcmljZVJhbmdlIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsImxhc3RWYWx1ZVZpc2libGUiLCJwcmljZUxpbmVWaXNpYmxlIiwicHJpY2VTY2FsZSIsInNjYWxlTWFyZ2lucyIsInRvcCIsImJvdHRvbSIsIm1hY2RQYW5lSWQiLCJEb3R0ZWQiLCJjcm9zc2hhaXJNYXJrZXJWaXNpYmxlIiwiY29tbW9uQkJMaW5lT3B0aW9ucyIsInJlbW92ZSIsImRpdiIsInJlZiIsInN0eWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/CandleChart.tsx\n"));

/***/ })

});